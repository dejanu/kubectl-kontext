#!/bin/bash

# kubectl-assess: Kubernetes Cluster Assessment Plugin
# Generates a report optimized for AI analysis
#
# Install:
#   cp kubectl-assess /usr/local/bin/ && chmod +x /usr/local/bin/kubectl-assess
#
# Usage:
#   kubectl assess                              # Output to stdout
#   kubectl assess | claude -p 'Analyze...'    # Pipe to AI
#   kubectl assess --help                       # Show help

set -euo pipefail

# Help
if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
    cat <<EOF
kubectl assess - Cluster assessment report for AI analysis

Usage:
  kubectl assess              Generate report to stdout
  kubectl assess > file.txt   Save report to file
  kubectl assess | claude -p 'Analyze this cluster'   Pipe to AI

Examples:
  kubectl assess | claude -p 'List critical issues and recommendations'
  kubectl assess | tee report.txt | claude -p 'Analyze' > analysis.md

Requires: jq
EOF
    exit 0
fi

# Check dependencies
# if ! command -v jq &>/dev/null; then
#     echo "Error: jq is required but not installed" >&2
#     exit 1
# fi

{
echo "=== KUBERNETES CLUSTER ASSESSMENT REPORT ==="
echo "Cluster: $(kubectl config current-context 2>/dev/null || echo 'unknown')"
echo "Generated: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
echo ""

# Quick metrics for AI summary
CLUSTER_NAME=$(kubectl config current-context 2>/dev/null || echo 'unknown')
CLUSTER_SERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}' 2>/dev/null || echo 'unknown')
TOTAL_NODES=$(kubectl get nodes --no-headers 2>/dev/null | wc -l | tr -d ' ')
TOTAL_PODS=$(kubectl get pods -A --no-headers 2>/dev/null | wc -l | tr -d ' ')
PODS_NO_LIMITS=$(kubectl get pods -A -o json 2>/dev/null | jq '[.items[] | select(.status.phase == "Running") | select(.spec.containers[] | .resources.limits == null or .resources.limits == {})] | length')
PODS_NO_REQUESTS=$(kubectl get pods -A -o json 2>/dev/null | jq '[.items[] | select(.status.phase == "Running") | select(.spec.containers[] | .resources.requests == null or .resources.requests == {})] | length')
WARNING_EVENTS=$(kubectl get events -A --field-selector type=Warning --no-headers 2>/dev/null | wc -l | tr -d ' ')
PENDING_PODS=$(kubectl get pods -A --field-selector=status.phase=Pending --no-headers 2>/dev/null | wc -l | tr -d ' ')
HIGH_RESTART_PODS=$(kubectl get pods -A -o json 2>/dev/null | jq '[.items[] | select(.status.containerStatuses != null) | select([.status.containerStatuses[].restartCount] | add > 10)] | length')

echo "## QUICK SUMMARY (for AI)"
echo "- Cluster Name: $CLUSTER_NAME"
echo "- Cluster Server: $CLUSTER_SERVER"
echo "- Nodes: $TOTAL_NODES"
echo "- Total Pods: $TOTAL_PODS"
echo "- Pods without resource limits: $PODS_NO_LIMITS"
echo "- Pods without resource requests: $PODS_NO_REQUESTS"
echo "- Warning events: $WARNING_EVENTS"
echo "- Pending pods: $PENDING_PODS"
echo "- High restart pods (>10): $HIGH_RESTART_PODS"
echo ""

# 1. Cluster Overview
echo "## CLUSTER OVERVIEW"
kubectl version --short 2>/dev/null || kubectl version | grep -E "Server|Client" | head -2
echo ""

# 2. Node Summary with Resources
echo "## NODES"
kubectl get nodes -o custom-columns='\
NAME:.metadata.name,\
STATUS:.status.conditions[?(@.type=="Ready")].status,\
ROLES:.metadata.labels.node-role\.kubernetes\.io/control-plane,\
VERSION:.status.nodeInfo.kubeletVersion,\
CPU:.status.allocatable.cpu,\
MEMORY:.status.allocatable.memory,\
PODS_CAPACITY:.status.allocatable.pods'
echo ""

# 3. Node Resource Allocation (Critical for overcommitment analysis)
echo "## NODE RESOURCE ALLOCATION"
for node in $(kubectl get nodes -o jsonpath='{.items[*].metadata.name}'); do
    echo "--- $node ---"
    kubectl describe node "$node" | sed -n '/Allocated resources:/,/Events:/p' | head -15
    echo ""
done

# 4. Resource Summary
echo "## RESOURCE SUMMARY"
echo "Total pods: $(kubectl get pods -A --no-headers 2>/dev/null | wc -l | tr -d ' ')"
echo ""
echo "Pods by namespace:"
kubectl get pods -A --no-headers | awk '{print $1}' | sort | uniq -c | sort -rn | head -15
echo ""

# 5. Pods Without Resource Configuration
echo "## PODS WITHOUT RESOURCE LIMITS"
kubectl get pods -A -o json | jq -r '
.items[] |
select(.status.phase == "Running") |
select(.spec.containers[] | .resources.limits == null or .resources.limits == {}) |
[.metadata.namespace, .metadata.name] | @tsv' 2>/dev/null | head -30
echo ""
echo "Count: $(kubectl get pods -A -o json | jq -r '.items[] | select(.status.phase == "Running") | select(.spec.containers[] | .resources.limits == null or .resources.limits == {}) | .metadata.name' 2>/dev/null | wc -l | tr -d ' ')"
echo ""

echo "## PODS WITHOUT RESOURCE REQUESTS"
kubectl get pods -A -o json | jq -r '
.items[] |
select(.status.phase == "Running") |
select(.spec.containers[] | .resources.requests == null or .resources.requests == {}) |
[.metadata.namespace, .metadata.name] | @tsv' 2>/dev/null | head -30
echo ""
echo "Count: $(kubectl get pods -A -o json | jq -r '.items[] | select(.status.phase == "Running") | select(.spec.containers[] | .resources.requests == null or .resources.requests == {}) | .metadata.name' 2>/dev/null | wc -l | tr -d ' ')"
echo ""

# 6. High Memory Limit Pods (Top 10)
echo "## TOP 10 MEMORY CONSUMERS (by limit)"
kubectl get pods -A -o json | jq -r '
[.items[] |
select(.status.phase == "Running") |
{
  ns: .metadata.namespace,
  name: .metadata.name,
  mem: ([.spec.containers[].resources.limits.memory // "0" |
    if endswith("Gi") then (rtrimstr("Gi") | tonumber * 1024)
    elif endswith("Mi") then (rtrimstr("Mi") | tonumber)
    else 0 end] | add)
}] | sort_by(-.mem) | .[:10] | .[] | "\(.ns)\t\(.name)\t\(.mem)Mi"' 2>/dev/null
echo ""

# 7. Pod Restarts (Top 10)
echo "## TOP 10 POD RESTARTS"
kubectl get pods -A -o json | jq -r '
[.items[] |
select(.status.containerStatuses != null) |
{
  ns: .metadata.namespace,
  name: .metadata.name,
  restarts: ([.status.containerStatuses[].restartCount] | add)
}] | sort_by(-.restarts) | .[:10] | .[] | select(.restarts > 0) | "\(.ns)\t\(.name)\t\(.restarts)"' 2>/dev/null
echo ""

# 8. Warning Events
echo "## RECENT WARNING EVENTS"
kubectl get events -A --field-selector type=Warning --sort-by='.lastTimestamp' 2>/dev/null | tail -20
echo ""

# 9. Pending/Problem Pods
echo "## PROBLEM PODS"
echo "Pending:"
kubectl get pods -A --field-selector=status.phase=Pending --no-headers 2>/dev/null || echo "None"
echo ""
echo "Failed:"
kubectl get pods -A --field-selector=status.phase=Failed --no-headers 2>/dev/null || echo "None"
echo ""

# 10. Storage Classes
echo "## STORAGE CLASSES"
kubectl get storageclasses -o custom-columns='NAME:.metadata.name,PROVISIONER:.provisioner,DEFAULT:.metadata.annotations.storageclass\.kubernetes\.io/is-default-class' 2>/dev/null
echo ""

# 11. PodDisruptionBudgets
echo "## POD DISRUPTION BUDGETS"
kubectl get pdb -A --no-headers 2>/dev/null || echo "None configured"
echo ""

# 12. LimitRanges and ResourceQuotas
echo "## LIMIT RANGES"
kubectl get limitranges -A --no-headers 2>/dev/null || echo "None configured"
echo ""

echo "## RESOURCE QUOTAS"
kubectl get resourcequotas -A --no-headers 2>/dev/null || echo "None configured"
echo ""

# 13. Network Policies Summary
echo "## NETWORK POLICIES"
kubectl get networkpolicies -A --no-headers 2>/dev/null | wc -l | xargs -I {} echo "Count: {}"
kubectl get networkpolicies -A -o custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name' --no-headers 2>/dev/null | head -10
echo ""

# 14. Node Taints
echo "## NODE TAINTS"
kubectl get nodes -o custom-columns='NODE:.metadata.name,TAINTS:.spec.taints[*].key' 2>/dev/null
echo ""

# 15. K3s Specific (if applicable)
echo "## K3S CONFIG (if applicable)"
kubectl get nodes -o jsonpath='{.items[0].metadata.annotations.k3s\.io/node-args}' 2>/dev/null | jq -r 'join(" ")' 2>/dev/null || echo "Not a K3s cluster or config not exposed"
echo ""

echo "=== END OF REPORT ==="
} 2>&1