#!/bin/bash

# kubectl-assess: Kubernetes Cluster Assessment Plugin
# Generates a report optimized for AI analysis
#
# Install:
#   cp kubectl-assess /usr/local/bin/ && chmod +x /usr/local/bin/kubectl-assess
#
# Usage:
#   kubectl assess                              # Output to stdout
#   kubectl assess | claude -p 'Analyze...'    # Pipe to AI
#   kubectl assess --help                       # Show help

set -euo pipefail

# Help
if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
    cat <<EOF
kubectl assess - Cluster assessment report for AI analysis

Usage:
  kubectl assess              Generate report to stdout
  kubectl assess > file.txt   Save report to file
  kubectl assess | claude -p 'Analyze this cluster'   Pipe to AI

Examples:
  kubectl assess | claude -p 'List critical issues and recommendations'
  kubectl assess | tee report.txt | claude -p 'Analyze' > analysis.md

Requires: jq
EOF
    exit 0
fi

# Check dependencies
# if ! command -v jq &>/dev/null; then
#     echo "Error: jq is required but not installed" >&2
#     exit 1
# fi

{
echo "=== KUBERNETES CLUSTER ASSESSMENT REPORT ==="
echo "Cluster: $(kubectl config current-context 2>/dev/null || echo 'unknown')"
echo "Generated: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
echo ""

# Quick metrics for AI summary
CLUSTER_NAME=$(kubectl config current-context 2>/dev/null || echo 'unknown')
CLUSTER_SERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}' 2>/dev/null || echo 'unknown')
TOTAL_NODES=$(kubectl get nodes --no-headers 2>/dev/null | wc -l | tr -d ' ')
TOTAL_PODS=$(kubectl get pods -A --no-headers 2>/dev/null | wc -l | tr -d ' ')
PODS_NO_LIMITS=$(kubectl get pods -A -o json 2>/dev/null | jq '[.items[] | select(.status.phase == "Running") | select(any(.spec.containers[]; .resources.limits == null or .resources.limits == {}))] | length')
PODS_NO_REQUESTS=$(kubectl get pods -A -o json 2>/dev/null | jq '[.items[] | select(.status.phase == "Running") | select(any(.spec.containers[]; .resources.requests == null or .resources.requests == {}))] | length')
WARNING_EVENTS=$(kubectl get events -A --field-selector type=Warning --no-headers 2>/dev/null | wc -l | tr -d ' ')
PENDING_PODS=$(kubectl get pods -A --field-selector=status.phase=Pending --no-headers 2>/dev/null | wc -l | tr -d ' ')
HIGH_RESTART_PODS=$(kubectl get pods -A -o json 2>/dev/null | jq '[.items[] | select(.status.containerStatuses != null) | select([.status.containerStatuses[].restartCount] | add > 10)] | length')

echo "## QUICK SUMMARY (for AI)"
echo "- Cluster Name: $CLUSTER_NAME"
echo "- Cluster Server: $CLUSTER_SERVER"
echo "- Nodes: $TOTAL_NODES"
echo "- Total Pods: $TOTAL_PODS"
echo "- Pods without resource limits: $PODS_NO_LIMITS"
echo "- Pods without resource requests: $PODS_NO_REQUESTS"
echo "- Warning events: $WARNING_EVENTS"
echo "- Pending pods: $PENDING_PODS"
echo "- High restart pods (>10): $HIGH_RESTART_PODS"
echo ""

# 1. Cluster Overview
echo "## CLUSTER OVERVIEW"
kubectl version --short 2>/dev/null || kubectl version | grep -E "Server|Client" | head -2
echo ""

# 2. Node Summary with Resources
echo "## NODES"
kubectl get nodes -o custom-columns='NAME:.metadata.name,STATUS:.status.conditions[?(@.type=="Ready")].status,ROLES:.metadata.labels.node-role\.kubernetes\.io/control-plane,VERSION:.status.nodeInfo.kubeletVersion,CPU:.status.allocatable.cpu,MEMORY:.status.allocatable.memory,PODS_CAPACITY:.status.allocatable.pods'
echo ""

# 3. Node Resource Allocation (Critical for overcommitment analysis)
echo "## NODE RESOURCE ALLOCATION"
for node in $(kubectl get nodes -o jsonpath='{.items[*].metadata.name}'); do
    echo "--- $node ---"
    kubectl describe node "$node" | sed -n '/Allocated resources:/,/Events:/p' | head -15
    echo ""
done

# 3b. Cluster-wide resource totals
echo "## CLUSTER-WIDE RESOURCE TOTALS"
kubectl get nodes -o json 2>/dev/null | jq -r '
  def parse_cpu: if endswith("m") then rtrimstr("m") | tonumber else tonumber * 1000 end;
  def parse_mem: if endswith("Ki") then (rtrimstr("Ki") | tonumber / 1024)
    elif endswith("Mi") then (rtrimstr("Mi") | tonumber)
    elif endswith("Gi") then (rtrimstr("Gi") | tonumber * 1024)
    else 0 end;
  "Total Allocatable CPU: \([.items[].status.allocatable.cpu | parse_cpu] | add)m",
  "Total Allocatable Memory: \([.items[].status.allocatable.memory | parse_mem] | add | round)Mi"
' 2>/dev/null || echo "Unable to compute"
echo ""

# 4. Resource Summary
echo "## RESOURCE SUMMARY"
echo "Pods by namespace:"
kubectl get pods -A --no-headers | awk '{print $1}' | sort | uniq -c | sort -rn | head -15
echo ""

# 5. Pods Without Resource Configuration
echo "## PODS WITHOUT RESOURCE LIMITS"
PODS_LIMITS_OUTPUT=$(kubectl get pods -A -o json 2>/dev/null | jq -r '
[.items[] |
select(.status.phase == "Running") |
select(any(.spec.containers[]; .resources.limits == null or .resources.limits == {})) |
[.metadata.namespace, .metadata.name] | @tsv] | unique[] ' 2>/dev/null | head -30)
if [[ -n "$PODS_LIMITS_OUTPUT" ]]; then
    echo "$PODS_LIMITS_OUTPUT"
    echo ""
    echo "Count: $(echo "$PODS_LIMITS_OUTPUT" | wc -l | tr -d ' ')"
else
    echo "None"
fi
echo ""

echo "## PODS WITHOUT RESOURCE REQUESTS"
PODS_REQUESTS_OUTPUT=$(kubectl get pods -A -o json 2>/dev/null | jq -r '
[.items[] |
select(.status.phase == "Running") |
select(any(.spec.containers[]; .resources.requests == null or .resources.requests == {})) |
[.metadata.namespace, .metadata.name] | @tsv] | unique[]' 2>/dev/null | head -30)
if [[ -n "$PODS_REQUESTS_OUTPUT" ]]; then
    echo "$PODS_REQUESTS_OUTPUT"
    echo ""
    echo "Count: $(echo "$PODS_REQUESTS_OUTPUT" | wc -l | tr -d ' ')"
else
    echo "None"
fi
echo ""

# 6. High Memory Limit Pods (Top 10)
echo "## TOP 10 MEMORY CONSUMERS (by limit)"
kubectl get pods -A -o json | jq -r '
[.items[] |
select(.status.phase == "Running") |
{
  ns: .metadata.namespace,
  name: .metadata.name,
  mem: ([.spec.containers[].resources.limits.memory // "0" |
    if endswith("Gi") then (rtrimstr("Gi") | tonumber * 1024)
    elif endswith("Mi") then (rtrimstr("Mi") | tonumber)
    else 0 end] | add)
}] | sort_by(-.mem) | .[:10] | .[] | "\(.ns)\t\(.name)\t\(.mem)Mi"' 2>/dev/null
echo ""

# 7. Pod Restarts (Top 10)
echo "## TOP 10 POD RESTARTS"
kubectl get pods -A -o json | jq -r '
[.items[] |
select(.status.containerStatuses != null) |
{
  ns: .metadata.namespace,
  name: .metadata.name,
  restarts: ([.status.containerStatuses[].restartCount] | add)
}] | sort_by(-.restarts) | .[:10] | .[] | select(.restarts > 0) | "\(.ns)\t\(.name)\t\(.restarts)"' 2>/dev/null
echo ""

# 8. Warning Events
echo "## RECENT WARNING EVENTS"
WARN_OUTPUT=$(kubectl get events -A --field-selector type=Warning --sort-by='.lastTimestamp' 2>/dev/null | tail -20)
if [[ -n "$WARN_OUTPUT" ]]; then echo "$WARN_OUTPUT"; else echo "None"; fi
echo ""

# 9. Pending/Problem Pods
echo "## PROBLEM PODS"
echo "Pending:"
PENDING_OUTPUT=$(kubectl get pods -A --field-selector=status.phase=Pending --no-headers 2>/dev/null)
if [[ -n "$PENDING_OUTPUT" ]]; then echo "$PENDING_OUTPUT"; else echo "None"; fi
echo ""
echo "Failed:"
FAILED_OUTPUT=$(kubectl get pods -A --field-selector=status.phase=Failed --no-headers 2>/dev/null)
if [[ -n "$FAILED_OUTPUT" ]]; then echo "$FAILED_OUTPUT"; else echo "None"; fi
echo ""

# 10. Storage Classes
echo "## STORAGE CLASSES"
kubectl get storageclasses -o custom-columns='NAME:.metadata.name,PROVISIONER:.provisioner,DEFAULT:.metadata.annotations.storageclass\.kubernetes\.io/is-default-class' 2>/dev/null
echo ""

# 11. PodDisruptionBudgets
echo "## POD DISRUPTION BUDGETS"
kubectl get pdb -A --no-headers 2>/dev/null || echo "None configured"
echo ""

# 12. LimitRanges and ResourceQuotas
echo "## LIMIT RANGES"
LR_OUTPUT=$(kubectl get limitranges -A --no-headers 2>/dev/null)
if [[ -n "$LR_OUTPUT" ]]; then echo "$LR_OUTPUT"; else echo "None configured"; fi
echo ""

echo "## RESOURCE QUOTAS"
RQ_OUTPUT=$(kubectl get resourcequotas -A --no-headers 2>/dev/null)
if [[ -n "$RQ_OUTPUT" ]]; then echo "$RQ_OUTPUT"; else echo "None configured"; fi
echo ""

# 13. Network Policies Summary
echo "## NETWORK POLICIES"
kubectl get networkpolicies -A --no-headers 2>/dev/null | wc -l | xargs -I {} echo "Count: {}"
kubectl get networkpolicies -A -o custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name' --no-headers 2>/dev/null | head -10
echo ""

# 14. Node Taints
echo "## NODE TAINTS"
kubectl get nodes -o custom-columns='NODE:.metadata.name,TAINTS:.spec.taints[*].key' 2>/dev/null
echo ""

# 15. K3s Specific (if applicable)
echo "## K3S CONFIG (if applicable)"
kubectl get nodes -o jsonpath='{.items[0].metadata.annotations.k3s\.io/node-args}' 2>/dev/null | jq -r 'join(" ")' 2>/dev/null || echo "Not a K3s cluster or config not exposed"
echo ""

echo "=== END OF REPORT ==="
} 2>&1
